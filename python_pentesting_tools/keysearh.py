"""
Lab 1 Part 1: Brute Forth Key Search
Authors: 
CSEC faculty
Put your name here: Miftahul Huq
"""

import multiprocessing
from cryptography.fernet import Fernet, InvalidToken
import base64
import multiprocessing
from threading import Thread
import time


def find_key(character_num, message, enc_message, process_queue):
    """
    This is a helper function that finds the key if there is no key
    found yet and adds it to the process queue. 
    Parameter:
    character_num: the character of the third to the last character
    message: the message
    enc_message: encrypted message
    process_queue: the queue that is being shared amonst all the processe
                    created by the program
    """
    if process_queue.empty():
        for i2 in range(65, 127):
            for i3 in range(65, 127):    
                key_source = "A"*29 + chr(character_num)+chr(i2)+chr(i3)   
                dec_message = decrypt(enc_message, key_source)
                if dec_message == message.encode():
                    process_queue.put(key_source)

def fast_key_search(message, enc_message):
    """
    The first 29 character of the 32 ascii characters have
    been set to "A"*29, and only the last 3 characters need
    to be found. This function divides up the work to find 
    the last 3 characters into 61 processes to make it fast
    to find the key. The last three chracters has ascii code
    from range 65-126. That's 61 characters for each characters.
    Parameters:
    message: original plaintex
    enc_message: ciphertext to be decrypted
    Return:
    The key source string used to encrypt/decrypt message 
    """
    process_queue = multiprocessing.Queue()
    #print(process_queue.get())
    for i in range(65, 127):
        running_process = multiprocessing.Process(target=find_key, args=(i, message, enc_message, process_queue))
        running_process.start()
    
    return process_queue.get()

def key_search(message, enc_message):
    """
    Brute force key source search
    A key source string is a sequence of 32 ascii characters 
    from which a symmetric key (used for both encryption and 
    decryption) is generated. 
    To reduce the search time complexity for the lab, the 
    first 29 characters have been set to "A"*29. You only 
    need to find the last three charactgers whose ascii code 
    is in the range 65-126.  
    Parameters:
    message: original plaintex
    enc_message: ciphertext to be decrypted
    Return:
    The key source string used to encrypt/decrypt message 
    """
    for i1 in range(65, 127): 
        for i2 in range(65, 127):
            for i3 in range(65, 127):    
                key_source = "A"*29 + chr(i1)+chr(i2)+chr(i3)   
                dec_message = decrypt(enc_message, key_source)
                if dec_message == message.encode():
                    return key_source
    return 'no key source found'

def encrypt(message, key_source):
    # Generate a key for encryption
    key = base64.urlsafe_b64encode(key_source.encode()) 
    # Create an instance the Fernet class with the key
    fernet = Fernet(key)
    # Use the instance to encrypt message 
    enc_message = fernet.encrypt(message.encode())
   
    return enc_message

def decrypt(enc_message, key_source):
    # Generate a key for decryption
    key = base64.urlsafe_b64encode(key_source.encode())

    # Create an instance the Fernet class with the key
    fernet = Fernet(key)

    # Use the instance to decrypt message 
    # If successfully decrypted you will receive the original 
    # plaintext as the result, 
    # otherwise an exception will be raised. 
    try: 
        dec_message = fernet.decrypt(enc_message) # For some reason stopping at this piont!!!
        return dec_message
    except InvalidToken:
        pass
    
# Demonstrate how the encryption and decryption functions are used
def enc_dec():
    key_source = 'A'*29+'abc'  # Any string of length 32 should work
    message = "Hello, Welcome to CSEC 201!"

    enc_message = encrypt(message, key_source) 
    print(f"enc_message = {enc_message}")
    
    dec_message = decrypt(enc_message, key_source)
    print(f"dec_message = {dec_message}")


if __name__ == "__main__":
    
    # enc_dec() 

    """
    Once you undestand encryption/decryption have the time to experiment,
    1. Comment out the call to enc_dec() 
    2. Uncomment the following lines to start lab 1 part 1
    """

    message = "Hello, Welcome to CSEC 201!"
    enc_message = b'gAAAAABhC01A7xgSLLzoZ_DD-WtMtmawT4dwB-R2UOmsBowJqBOS0HWjx42rcIVFx_3bMdtJlH0zLFVLdTx3mx5F8K1I3k0ykoYX5M0eeZuJgeff82KPoGY='
    print('Slow search starts...')
    start = time.perf_counter()
    key_source = fast_key_search(message, enc_message)
    print(f"key source found is {key_source}")
    end = time.perf_counter()
    print(f'Slow search is done in {round(end-start, 2)} seconds')